// --- BỘ INCLUDE ĐÚNG THỨ TỰ ---

// 1. Luôn đặt Winsock2 trước Windows.h để tránh xung đột định nghĩa
// Winsock2.h chứa các khai báo cho Windows Sockets API, cần thiết cho các hoạt động mạng.
// Phải đặt trước Windows.h vì Windows.h có thể include một phiên bản cũ hơn của Winsock (winsock.h)
// gây ra lỗi biên dịch do định nghĩa lại các cấu trúc và hàm.
#include <winsock2.h>

// 2. Header chính của Windows
// Windows.h là header trung tâm cho Windows API, chứa định nghĩa cho hầu hết các hàm,
// kiểu dữ liệu và hằng số cơ bản của Windows.
#include <windows.h>

// 3. Header cho các API mạng phụ trợ (phụ thuộc vào 1 và 2)
// Iphlpapi.h (IP Helper API) cung cấp các hàm để truy vấn và cấu hình thông tin mạng,
// ví dụ như lấy địa chỉ MAC, thông tin adapter mạng.
#include <iphlpapi.h>

// --- Các header khác ---
// Iostream cần cho việc xuất dữ liệu ra console (ví dụ: std::cout).
#include <iostream>
// Vector cần cho việc sử dụng std::vector, một cấu trúc dữ liệu mảng động.
#include <vector>
// TlHelp32.h chứa các khai báo cho Tool Help Library, dùng để lấy thông tin
// về các tiến trình, thread, module đang chạy (trong code này không dùng trực tiếp nhưng có thể liên quan).
#include <TlHelp32.h>
// Intrin.h chứa các hàm nội tại (intrinsics) của trình biên dịch, cho phép truy cập
// các lệnh đặc biệt của CPU như CPUID.
#include <intrin.h>
// String cần cho việc sử dụng std::string để xử lý chuỗi ký tự.
#include <string>

// --- Header của bạn ---
// "anti_analysis.h" có lẽ chứa khai báo của lớp AntiAnalysis.
#include "anti_analysis.h"
// "utils.h" có thể chứa các hàm tiện ích, ví dụ như Utils::seflDestroy().
#include "utils.h"

// Lệnh liên kết thư viện
// #pragma comment(lib, "iphlpapi.lib") chỉ thị cho trình liên kết (linker)
// tự động liên kết với thư viện iphlpapi.lib. Thư viện này chứa
// mã thực thi cho các hàm trong Iphlpapi.h (ví dụ: GetAdaptersAddresses).
#pragma comment(lib, "iphlpapi.lib")

// Khai báo namespace
// using namespace std; mang tất cả các tên trong namespace std (standard library)
// vào phạm vi toàn cục, cho phép gọi các thành phần như cout, vector, string
// mà không cần tiền tố std::.
using namespace std;

// --- Phần còn lại của mã nguồn ---

// cnstructor: Hàm khởi tạo của lớp AntiAnalysis
AntiAnalysis::AntiAnalysis() {
	// In ra thông báo bắt đầu quá trình kiểm tra.
	cout << "  [*] Bắt đầu kiểm tra chống phân tích..." << endl;

	// --- CÁC KỸ THUẬT CHỐNG DEBUGGER ---
	// 1. IsDebuggerPresentCheck: Kiểm tra xem tiến trình có đang bị debug bằng API IsDebuggerPresent không.
	IsDebuggerPresentCheck();
	// 2. CheckRemoteDebuggerPresentCheck: Kiểm tra xem có debugger từ xa nào đang gắn vào tiến trình không.
	CheckRemoteDebuggerPresentCheck();
	// 3. NtQueryInformationProcessCheck: Kiểm tra cờ debug của tiến trình thông qua NtQueryInformationProcess.
	NtQueryInformationProcessCheck();
	// 4. TimingCheck: Kiểm tra sự khác biệt về thời gian thực thi để phát hiện debugger/sandbox làm chậm tiến trình.
	TimingCheck();
	// 5. PEBFlagCheck: Kiểm tra cờ 'BeingDebugged' trong Process Environment Block (PEB).
	PEBFlagCheck();

	// --- CÁC KỸ THUẬT CHỐNG MÁY ẢO/SANDBOX ---
	// 6. checkVirtualHardwareConfig: Kiểm tra cấu hình phần cứng (CPU, RAM) xem có dấu hiệu của máy ảo không.
	checkVirtualHardwareConfig();
	// 7. checkVMDrivers: Kiểm tra sự tồn tại của các driver hoặc thiết bị đặc trưng của máy ảo.
	checkVMDrivers();
	// 8. checkHypervisorArtifacts: Kiểm tra các "tạo tác" (registry keys, MAC address prefixes) do hypervisor để lại.
	checkHypervisorArtifacts();
	// 9. CPUIDInterrogationCheck: Truy vấn thông tin CPU bằng lệnh CPUID để phát hiện hypervisor.
	CPUIDInterrogationCheck();
	// 10. SystemUserBehaviorAnalysisCheck: Phân tích hành vi hệ thống và người dùng (thời gian uptime, di chuyển chuột).
	SystemUserBehaviorAnalysisCheck();
}


// destructor: Hàm hủy của lớp AntiAnalysis
// Hiện tại hàm hủy không làm gì cả.
AntiAnalysis::~AntiAnalysis() {}


// IsDebuggerPresentCheck: Kiểm tra xem tiến trình có đang chạy dưới một debugger không.
// API IsDebuggerPresent() là một hàm đơn giản của Windows API.
// Nó kiểm tra một cờ trong PEB (Process Environment Block) của tiến trình.
// Nếu tiến trình đang được debug, cờ này sẽ được setzen.
void AntiAnalysis::IsDebuggerPresentCheck() {
	if (IsDebuggerPresent()) { // Gọi API IsDebuggerPresent()
		// Nếu hàm trả về TRUE (khác 0), nghĩa là có debugger.
		cout << "  [*] Phát hiện debugger bằng IsDebuggerPresentCheck." << endl;
		Utils::seflDestroy(); // Gọi hàm tự hủy (có thể là xóa file thực thi).
		 //ExitProcess(0);       // Kết thúc tiến trình ngay lập tức.
	}
}

// CheckRemoteDebuggerPresentCheck: Kiểm tra xem có debugger từ xa nào đang gắn vào tiến trình không.
// API CheckRemoteDebuggerPresent() kiểm tra xem một tiến trình cụ thể (ở đây là tiến trình hiện tại)
// có đang được debug từ xa hay không.
void AntiAnalysis::CheckRemoteDebuggerPresentCheck() {
	BOOL debuggerPresent = FALSE; // Biến để lưu kết quả (TRUE nếu có debugger).
	// GetCurrentProcess() trả về một handle tới tiến trình hiện tại.
	// &debuggerPresent là địa chỉ của biến sẽ nhận kết quả.
	// Hàm trả về TRUE nếu kiểm tra thành công (dù có debugger hay không).
	// Giá trị thực sự của việc có debugger hay không nằm trong biến debuggerPresent.
	if (CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent)) {
		if (debuggerPresent) { // Chỉ thoát nếu debuggerPresent là TRUE
			cout << "  [*] Phát hiện debugger từ xa bằng CheckRemoteDebuggerPresentCheck." << endl;
			Utils::seflDestroy(); // Tự hủy.
		//	ExitProcess(0);       // Kết thúc tiến trình.
		}
	}
}


// NtQueryInformationProcessCheck: Kiểm tra cờ debug của tiến trình bằng cách sử dụng NtQueryInformationProcess.
// Hàm này truy vấn thông tin về một tiến trình cụ thể.
// Đây là một hàm "undocumented" (không chính thức được Microsoft hỗ trợ đầy đủ tài liệu cho lập trình viên ứng dụng)
// và nằm trong ntdll.dll, thường được gọi trực tiếp vào kernel mode.
void AntiAnalysis::NtQueryInformationProcessCheck() {
	/*
	 * Cách hoạt động:
	 * Truy vấn trường ProcessDebugPort (có ProcessInformationClass ID là 7) của tiến trình hiện tại.
	 * Nếu giá trị của ProcessDebugPort khác 0, điều đó có nghĩa là một debugger đang được gắn vào cổng debug của tiến trình.
	 */

	 // Định nghĩa kiểu con trỏ hàm cho NtQueryInformationProcess.
	 // Tham số:
	 //  - HANDLE ProcessHandle: Handle tới tiến trình cần truy vấn.
	 //  - ULONG ProcessInformationClass: Loại thông tin cần truy vấn (ở đây là 7 cho ProcessDebugPort).
	 //  - PVOID ProcessInformation: Con trỏ tới buffer nhận thông tin.
	 //  - ULONG ProcessInformationLength: Kích thước của buffer.
	 //  - PULONG ReturnLength: Con trỏ tới biến nhận kích thước thực sự của thông tin trả về (có thể là NULL).
	typedef NTSTATUS(WINAPI* NtQueryInformationProcessFunc)(HANDLE, ULONG, PVOID, ULONG, PULONG);

	// Lấy địa chỉ của hàm NtQueryInformationProcess từ ntdll.dll.
	// GetModuleHandleA("ntdll.dll") lấy handle của module ntdll.dll đã được nạp vào tiến trình.
	// GetProcAddress() tìm địa chỉ của hàm có tên "NtQueryInformationProcess" trong module đó.
	NtQueryInformationProcessFunc NtQueryInformationProcess = (NtQueryInformationProcessFunc)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryInformationProcess");

	if (NtQueryInformationProcess) { // Nếu địa chỉ hàm được tìm thấy (khác NULL)
		DWORD debugPort = 0; // Biến để lưu giá trị ProcessDebugPort.
		// Gọi NtQueryInformationProcess.
		// GetCurrentProcess() lấy handle của tiến trình hiện tại.
		// 7 là ProcessInformationClass cho ProcessDebugPort.
		// &debugPort là buffer nhận kết quả.
		// sizeof(DWORD) là kích thước của buffer.
		// NULL vì không cần biết kích thước trả về.
		NTSTATUS status = NtQueryInformationProcess(GetCurrentProcess(), 7, &debugPort, sizeof(DWORD), NULL);

		// status == 0 (STATUS_SUCCESS) nghĩa là hàm thực thi thành công.
		// debugPort != 0 nghĩa là có debugger đang gắn vào.
		if (status == 0 && debugPort != 0) {
			cout << "  [*] Phát hiện debugger bằng NtQueryInformationProcessCheck (ProcessDebugPort)." << endl;
			Utils::seflDestroy();
		//	ExitProcess(0);
		}
	}
}


// TimingCheck: Kiểm tra sự khác biệt về thời gian thực thi để phát hiện debugger/sandbox.
// Kỹ thuật này dựa trên việc debugger hoặc sandbox có thể làm chậm quá trình thực thi của chương trình,
// đặc biệt là khi các hàm như Sleep() được gọi, hoặc khi có breakpoint, stepping.
void AntiAnalysis::TimingCheck() {
	/*
	 * Cách hoạt động:
	 * Lấy thời gian hệ thống trước khi gọi Sleep().
	 * Gọi Sleep(10) để tạm dừng chương trình trong khoảng 10 mili giây.
	 * Lấy lại thời gian hệ thống sau khi Sleep() kết thúc.
	 * Tính toán thời gian thực tế đã trôi qua.
	 * Nếu thời gian thực tế lớn hơn nhiều so với thời gian dự kiến (10ms),
	 * có thể là do debugger hoặc sandbox đã can thiệp, làm chậm quá trình thực thi.
	 */
	DWORD start = GetTickCount(); // GetTickCount() trả về số mili giây kể từ khi hệ thống khởi động.
	Sleep(10);                    // Tạm dừng thực thi trong (khoảng) 10 mili giây.
	DWORD elapsed = GetTickCount() - start; // Tính thời gian đã trôi qua.

	// Ngưỡng 20ms được chọn ở đây. Nếu thời gian trôi qua lớn hơn 20ms (thay vì ~10ms),
	// có thể có sự can thiệp. Giá trị này có thể cần điều chỉnh tùy theo hệ thống.
	if (elapsed > 20) {
		cout << "  [*] Phát hiện khả năng bị debug/sandbox bằng TimingCheck (thời gian Sleep bất thường)." << endl;
		Utils::seflDestroy();
	//	ExitProcess(0);
	}
}

// PEBFlagCheck: Kiểm tra cờ 'BeingDebugged' trong Process Environment Block (PEB).
// PEB là một cấu trúc dữ liệu trong user mode chứa thông tin về tiến trình.
// Hệ điều hành sẽ tự động đặt cờ 'BeingDebugged' trong PEB khi một debugger được gắn vào tiến trình.
/*
 * Giải thích về PEB và cách truy cập:
 * PEB (Process Environment Block) là một cấu trúc dữ liệu do kernel quản lý nhưng nằm trong không gian địa chỉ của tiến trình người dùng.
 * Nó chứa nhiều thông tin quan trọng về tiến trình, bao gồm cả một byte cờ tên là 'BeingDebugged'.
 *
 * Địa chỉ của PEB có thể được lấy thông qua thanh ghi FS (trên x86) hoặc GS (trên x64):
 * - Trên Windows 32-bit (x86): PEB nằm ở địa chỉ được trỏ bởi FS:[0x30].
 * - Trên Windows 64-bit (x64): PEB nằm ở địa chỉ được trỏ bởi GS:[0x60].
 *
 * Cấu trúc PEB (rút gọn):
 * typedef struct _PEB {
 * BYTE InheritedAddressSpace;    // Offset +0x000
 * BYTE ReadImageFileExecOptions; // Offset +0x001
 * BYTE BeingDebugged;            // Offset +0x002  <--- Cờ này được sử dụng để phát hiện debugger.
 * BYTE Spare;                    // Offset +0x003
 * // ... và nhiều trường khác
 * } PEB, *PPEB;
 *
 * Các macro tiền xử lý #ifdef, #ifndef, #else, #endif:
 * Đây là các chỉ thị cho trình tiền xử lý của C/C++. Chúng được sử dụng để biên dịch có điều kiện các đoạn mã.
 * - _M_IX86: Macro này được định nghĩa bởi trình biên dịch MSVC khi đang build cho kiến trúc 32-bit x86.
 * - Nếu build cho 64-bit, macro này sẽ không được định nghĩa.
 *
 * Mã assembly inline (ví dụ cho 32-bit, không dùng trong code hiện tại nhưng để tham khảo):
 * #ifdef _M_IX86
 * __asm {
 * mov eax, fs:[0x30]      // EAX = địa chỉ của PEB
 * movzx ebx, byte ptr [eax + 2] // EBX = giá trị của cờ BeingDebugged (byte ở offset +2 từ địa chỉ PEB)
 * test ebx, ebx           // Kiểm tra EBX có bằng 0 không. Nếu EBX=0, ZF=1. Nếu EBX!=0, ZF=0.
 * jnz debugger_detected   // Nếu EBX != 0 (ZF=0), nhảy đến nhãn debugger_detected
 * // ...
 * debugger_detected:
 * ExitProcess(0);
 * }
 * #endif
 *
 * Trong code hiện tại, chúng ta sử dụng các hàm nội tại (intrinsics) của MSVC để đọc từ FS/GS:
 * - __readfsdword(0x30) cho 32-bit.
 * - __readgsqword(0x60) cho 64-bit.
 */
void AntiAnalysis::PEBFlagCheck() {
	PBYTE pPEB = NULL; // Con trỏ kiểu byte trỏ đến PEB.

#ifdef _M_IX86 // Nếu đang biên dịch cho kiến trúc 32-bit (x86)
	// __readfsdword(0x30) là một hàm nội tại (intrinsic) của MSVC.
	// Nó đọc một DWORD (4 byte) từ địa chỉ FS:[0x30], chính là địa chỉ của PEB.
	pPEB = (PBYTE)__readfsdword(0x30);
#else // Ngược lại, nếu đang biên dịch cho kiến trúc 64-bit (x64) hoặc khác
	// __readgsqword(0x60) là một hàm nội tại (intrinsic) của MSVC.
	// Nó đọc một QWORD (8 byte) từ địa chỉ GS:[0x60], chính là địa chỉ của PEB trên x64.
	pPEB = (PBYTE)__readgsqword(0x60);
#endif

	// Cờ 'BeingDebugged' là một byte nằm ở offset +2 byte tính từ đầu cấu trúc PEB.
	// *(pPEB + 2) truy cập vào byte này.
	BYTE beingDebugged = *(pPEB + 2);

	if (beingDebugged) { // Nếu giá trị của cờ BeingDebugged khác 0 (TRUE)
		cout << "  [*] Phát hiện debugger bằng PEBFlagCheck (cờ BeingDebugged)." << endl;
		Utils::seflDestroy();
	//	ExitProcess(0); // Thoát chương trình.
	}
}


// checkVirtualHardwareConfig: Kiểm tra cấu hình phần cứng ảo (CPU, RAM) để phát hiện máy ảo.
// Máy ảo thường được cấu hình với số lượng core CPU và dung lượng RAM ít hơn so với máy thật để tiết kiệm tài nguyên.
/*
 * SYSTEM_INFO: Là một struct chứa thông tin về hệ thống máy tính hiện tại.
 * Được sử dụng với hàm GetSystemInfo().
 * Các trường quan trọng:
 * - dwNumberOfProcessors: Số lượng bộ xử lý logic (core/thread) trong hệ thống. Máy ảo thường có ít.
 *
 * MEMORYSTATUSEX: Là một struct chứa thông tin về tình trạng bộ nhớ vật lý và ảo của hệ thống.
 * Được sử dụng với hàm GlobalMemoryStatusEx().
 * Các trường quan trọng:
 * - ullTotalPhys: Tổng dung lượng RAM vật lý (tính bằng byte). Máy ảo thường có RAM ít.
 *
 * Logic kiểm tra:
 * - Nếu số lượng core logic <= 4 (ngưỡng này có thể cần điều chỉnh, máy thật hiện đại thường có nhiều hơn 4 core logic,
 * trong khi máy ảo có thể chỉ được cấp 1, 2 hoặc 4 core).
 * - Nếu tổng RAM vật lý < 4GB. Máy ảo thường được cấp ít RAM (ví dụ: 1GB, 2GB) để hoạt động nhẹ nhàng.
 */
void AntiAnalysis::checkVirtualHardwareConfig() {
	SYSTEM_INFO sysInfo;         // Khai báo biến kiểu SYSTEM_INFO.
	GetSystemInfo(&sysInfo);     // Gọi API GetSystemInfo() để điền thông tin vào sysInfo.

	MEMORYSTATUSEX memStatus;    // Khai báo biến kiểu MEMORYSTATUSEX.
	memStatus.dwLength = sizeof(memStatus); // Quan trọng: Phải khởi tạo trường dwLength trước khi gọi GlobalMemoryStatusEx.
	GlobalMemoryStatusEx(&memStatus); // Gọi API GlobalMemoryStatusEx() để điền thông tin vào memStatus.

	// Kiểm tra số lượng core logic.
	// sysInfo.dwNumberOfProcessors chứa số lượng bộ xử lý logic.
	if (sysInfo.dwNumberOfProcessors <= 4) {
		// Ngưỡng này được chọn là 4. Nếu số core <= 4, có thể là máy ảo.
		// Lưu ý: Một số máy thật cũ hoặc cấu hình thấp cũng có thể có <= 4 core.
		// Việc tăng lên 4 là để tránh false positive trên các máy ảo được người dùng cố tình tăng core lên để đỡ giật lag.
		cout << "  [*] Phát hiện khả năng là máy ảo: Số lượng core CPU thấp (" << sysInfo.dwNumberOfProcessors << " cores)." << endl;
		Utils::seflDestroy();
		ExitProcess(0);
	}

	// Kiểm tra RAM vật lý.
	// memStatus.ullTotalPhys chứa tổng dung lượng RAM vật lý bằng byte.
	// 4 * 1024 * 1024 * 1024 tương đương 4GB.
	if (memStatus.ullTotalPhys < (4ULL * 1024 * 1024 * 1024)) {
		// Nếu RAM < 4GB, có khả năng cao là máy ảo.
		cout << "  [*] Phát hiện khả năng là máy ảo: Dung lượng RAM thấp (" << (memStatus.ullTotalPhys / (1024 * 1024)) << " MB)." << endl;
		Utils::seflDestroy();
	//	ExitProcess(0);
	}
}

// checkVMDrivers: Kiểm tra sự tồn tại của các tệp driver hoặc thiết bị đặc trưng của máy ảo.
// Các nhà cung cấp máy ảo (VirtualBox, VMware, QEMU, Parallels) thường cài đặt các driver
// hoặc tạo ra các thiết bị ảo với tên gọi đặc trưng để hỗ trợ tương tác giữa máy ảo và máy chủ.
void AntiAnalysis::checkVMDrivers() {
	// --- PHẦN 1: KIỂM TRA SỰ TỒN TẠI CỦA CÁC TỆP TIN DRIVER ĐẶC TRƯNG CỦA VM ---

	// Lấy đường dẫn đến thư mục hệ thống (thường là C:\Windows).
	char systemBuffer[MAX_PATH]; // MAX_PATH là hằng số định nghĩa độ dài tối đa của một đường dẫn (thường là 260).
	// GetEnvironmentVariableA() lấy giá trị của một biến môi trường.
	// "SystemRoot" là biến môi trường trỏ đến thư mục cài đặt Windows.
	GetEnvironmentVariableA("SystemRoot", systemBuffer, MAX_PATH);

	// Tạo đường dẫn đầy đủ đến thư mục drivers: C:\Windows\System32\drivers\

	// Danh sách các tệp driver đáng ngờ và tên máy ảo tương ứng.
	// Mỗi phần tử là một std::pair, với first là tên file driver, second là tên VM.
	string driversPath = string(systemBuffer) + "\\System32\\drivers\\";
	vector<pair<const char*, const char*>> suspiciousDrivers = {
		// VirtualBox
		{ "VBoxMouse.sys",    "VirtualBox" }, // Driver chuột cho VirtualBox Guest Additions
		{ "VBoxGuest.sys",    "VirtualBox" }, // Driver chính cho VirtualBox Guest Additions
		{ "VBoxSF.sys",       "VirtualBox" }, // Driver cho Shared Folders của VirtualBox
		{ "VBoxVideo.sys",    "VirtualBox" }, // Driver video cho VirtualBox
		// VMware
		{ "vmhgfs.sys",       "VMware" },     // Driver cho VMware Shared Folders (Host Guest File System)
		{ "vmmouse.sys",      "VMware" },     // Driver chuột cho VMware Tools
		{ "vmsci.sys",        "VMware" },     // Driver VMware VMCI (Virtual Machine Communication Interface)
		{ "vmx_svga.sys",     "VMware" },     // Driver video SVGA cho VMware
		// QEMU/KVM (sử dụng VirtIO drivers)
		{ "vioser.sys",       "QEMU/KVM (VirtIO)" }, // Driver VirtIO serial
		// Parallels
		{ "prl_fs.sys",       "Parallels" }    // Driver cho Parallels File System
	};

	// Duyệt qua danh sách các driver đáng ngờ.
	for (const auto& driverInfo : suspiciousDrivers) {
		string fullPath = driversPath + driverInfo.first; // Tạo đường dẫn đầy đủ tới file driver.
		// GetFileAttributesA() trả về thuộc tính của một file hoặc thư mục.
		// Nếu file không tồn tại, hàm trả về INVALID_FILE_ATTRIBUTES.
		if (GetFileAttributesA(fullPath.c_str()) != INVALID_FILE_ATTRIBUTES) {
			// Nếu file tồn tại, có nghĩa là driver của VM đã được cài đặt.
			cout << "  [*] Phát hiện driver của máy ảo: " << driverInfo.first << " (cho " << driverInfo.second << ")." << endl;
			// Utils::seflDestroy(); // Cân nhắc có nên tự hủy ở đây không, vì phát hiện driver không có nghĩa là đang chạy trong VM.
		//	ExitProcess(0); // Thoát chương trình.
		}
	}

	// --- PHẦN 2: KIỂM TRA SỰ TỒN TẠI CỦA CÁC THIẾT BỊ ẢO ĐẶC TRƯNG CỦA VM ---
	/*
	 * Cách hoạt động:
	 * Máy ảo thường tạo ra các device objects (thiết bị ảo) trong hệ thống với tên gọi đặc trưng.
	 * Ví dụ: VirtualBox tạo thiết bị \\.\VBoxGuest.
	 * Ta có thể thử mở các thiết bị này bằng API CreateFileA().
	 * Nếu CreateFileA() thành công (trả về một handle hợp lệ, khác INVALID_HANDLE_VALUE),
	 * điều đó có nghĩa là thiết bị ảo đó đang tồn tại, và rất có thể chương trình đang chạy trong VM.
	 */
	 // Danh sách các tên thiết bị ảo đáng ngờ.
	 // Tên thiết bị thường có dạng \\.\DeviceName
	vector<pair<const char*, const char*>> suspiciousDevices = {
		{ "\\\\.\\VBoxGuest", "VirtualBox" }, // Thiết bị của VirtualBox Guest Additions
		{ "\\\\.\\HGFS",      "VMware" },     // Thiết bị VMware HGFS (Host Guest File System)
		{ "\\\\.\\Vmci",      "VMware" }      // Thiết bị VMware VMCI (Virtual Machine Communication Interface)
	};

	// Duyệt qua danh sách các thiết bị đáng ngờ.
	for (const auto& deviceInfo : suspiciousDevices) {
		// Thử mở thiết bị.
		// Tham số của CreateFileA():
		//   - deviceInfo.first: Tên thiết bị.
		//   - 0: Không yêu cầu quyền truy cập cụ thể (chỉ kiểm tra sự tồn tại).
		//   - 0: Không chia sẻ quyền truy cập.
		//   - NULL: Thuộc tính bảo mật mặc định.
		//   - OPEN_EXISTING: Chỉ mở nếu thiết bị đã tồn tại.
		//   - 0: Cờ và thuộc tính file (không áp dụng cho thiết bị).
		//   - NULL: Không có template file.
		HANDLE hDevice = CreateFileA(deviceInfo.first, 0, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hDevice != INVALID_HANDLE_VALUE) { // Nếu handle hợp lệ (khác INVALID_HANDLE_VALUE)
			// Thiết bị tồn tại, nghĩa là đang chạy trong VM.
			cout << "  [*] Phát hiện thiết bị của máy ảo: " << deviceInfo.first << " (cho " << deviceInfo.second << ")." << endl;
			CloseHandle(hDevice); // Đóng handle của thiết bị ngay lập tức.
			Utils::seflDestroy();
		//	ExitProcess(0); // Thoát chương trình.
		}
	}
}


// checkHypervisorArtifacts: Kiểm tra các "tạo tác" (artifacts) do hypervisor để lại,
// như các khóa registry đặc trưng hoặc các tiền tố địa chỉ MAC của card mạng ảo.
void AntiAnalysis::checkHypervisorArtifacts() {
	// --- PHẦN 1: KIỂM TRA CÁC KHÓA REGISTRY ĐẶC TRƯNG CỦA VM/HYPERVISOR ---
	/*
	 * Cách hoạt động:
	 * Khi cài đặt phần mềm máy ảo hoặc các công cụ hỗ trợ (như VMware Tools, VirtualBox Guest Additions),
	 * chúng thường tạo ra các khóa (key) và giá trị (value) trong Windows Registry.
	 * Việc kiểm tra sự tồn tại của các khóa này có thể giúp phát hiện VM.
	 *
	 * API RegOpenKeyExA(): Mở một khóa registry đã tồn tại.
	 * Tham số:
	 * - HKEY hKey: Handle tới một khóa cha đã mở (ví dụ: HKEY_LOCAL_MACHINE).
	 * - LPCSTR lpSubKey: Tên của khóa con cần mở.
	 * - DWORD ulOptions: Tùy chọn (thường là 0).
	 * - REGSAM samDesired: Quyền truy cập mong muốn (ví dụ: KEY_READ để đọc).
	 * - PHKEY phkResult: Con trỏ nhận về handle của khóa vừa được mở.
	 * Hàm trả về ERROR_SUCCESS (giá trị 0) nếu mở khóa thành công.
	 */
	vector<const char*> suspiciousRegistryKeys = {
		// VMware
		"SOFTWARE\\VMware, Inc.\\VMware Tools", // Khóa cài đặt VMware Tools
		"SYSTEM\\CurrentControlSet\\Services\\VMTools", // Dịch vụ VMware Tools
		"HARDWARE\\ACPI\\DSDT\\VBOX__", // Dấu hiệu trong ACPI DSDT table (thường cho VirtualBox nhưng có thể lẫn) - chú ý tên VBOX
		// VirtualBox
		"SOFTWARE\\Oracle\\VirtualBox Guest Additions", // Khóa cài đặt VirtualBox Guest Additions
		"SOFTWARE\\VBoxGuest", // Một khóa khác của VirtualBox
		"SYSTEM\\CurrentControlSet\\Services\\VBoxGuest", // Dịch vụ VirtualBox Guest
		// QEMU/KVM
		"SOFTWARE\\QEMU", // Dấu hiệu của QEMU
		"HARDWARE\\ACPI\\DSDT\\QEMU", // Dấu hiệu QEMU trong ACPI DSDT table
		// Parallels
		"SYSTEM\\CurrentControlSet\\Services\\prl_tg", // Dịch vụ Parallels Tools Guest Agent
		// Hyper-V
		"SYSTEM\\CurrentControlSet\\Services\\vmicheartbeat", // Dịch vụ Hyper-V Heartbeat
		"SYSTEM\\CurrentControlSet\\Services\\vmicvss",      // Dịch vụ Hyper-V Volume Shadow Copy Requestor
	};

	// Duyệt qua danh sách các khóa registry đáng ngờ.
	for (const auto& keyPath : suspiciousRegistryKeys) {
		HKEY hKey; // Biến để lưu handle của khóa registry.
		// Thử mở khóa registry với quyền đọc (KEY_READ).
		// HKEY_LOCAL_MACHINE là một trong các khóa gốc của Registry, chứa thông tin cấu hình máy tính.
		LONG result = RegOpenKeyExA(HKEY_LOCAL_MACHINE, keyPath, 0, KEY_READ, &hKey);
		if (result == ERROR_SUCCESS) { // Nếu hàm trả về ERROR_SUCCESS (0), khóa tồn tại.
			cout << "  [*] Phát hiện khóa Registry của máy ảo/hypervisor: " << keyPath << endl;
			RegCloseKey(hKey); // Đóng handle của khóa registry đã mở.
			Utils::seflDestroy();
		//	ExitProcess(0);
		}
	}

	// --- PHẦN 2: KIỂM TRA CÁC TIỀN TỐ (PREFIXES) CỦA ĐỊA CHỈ MAC ---
	/*
	 * Cách hoạt động:
	 * Mỗi card mạng (Network Interface Card - NIC) có một địa chỉ MAC (Media Access Control) duy nhất.
	 * Địa chỉ MAC gồm 6 byte. Ba byte đầu tiên (OUI - Organizationally Unique Identifier) thường
	 * được gán cho nhà sản xuất.
	 * Các máy ảo thường sử dụng card mạng ảo với địa chỉ MAC có OUI thuộc về nhà cung cấp VM đó.
	 * Ví dụ:
	 * - VMware: 00:05:69, 00:0C:29, 00:50:56
	 * - VirtualBox: 08:00:27
	 * - Parallels: 00:1C:42
	 * - Hyper-V: 00:15:5D
	 *
	 * API GetAdaptersAddresses(): Lấy thông tin về các adapter mạng trong hệ thống.
	 * - Cần gọi 2 lần:
	 * 1. Lần đầu với buffer là NULL để lấy kích thước buffer cần thiết (`bufferSize`).
	 * 2. Cấp phát buffer với kích thước đó, rồi gọi lần nữa để lấy dữ liệu.
	 * - Trả về một danh sách liên kết (linked list) các cấu trúc IP_ADAPTER_ADDRESSES.
	 *
	 * IP_ADAPTER_ADDRESSES struct:
	 * - PhysicalAddress[MAX_ADAPTER_ADDRESS_LENGTH]: Mảng byte chứa địa chỉ MAC.
	 * - PhysicalAddressLength: Độ dài của địa chỉ MAC (thường là 6 cho Ethernet).
	 * - Next: Con trỏ tới adapter tiếp theo trong danh sách.
	 */
	ULONG bufferSize = 0; // Biến lưu kích thước buffer cần thiết.
	// Lần gọi đầu tiên:
	//   - AF_UNSPEC: Lấy thông tin cho cả IPv4 và IPv6 adapters.
	//   - Các tham số khác: flags=0, reserved=NULL.
	//   - AdapterAddresses=NULL: để hàm trả về kích thước cần thiết vào bufferSize.
	// Hàm sẽ trả về ERROR_BUFFER_OVERFLOW nếu bufferSize ban đầu (0) là quá nhỏ,
	// và đặt giá trị bufferSize thành kích thước thực sự cần.
	if (GetAdaptersAddresses(AF_UNSPEC, 0, NULL, NULL, &bufferSize) == ERROR_BUFFER_OVERFLOW) {
		vector<BYTE> buffer(bufferSize); // Cấp phát buffer động với kích thước đã lấy được.
		// Ép kiểu con trỏ buffer.data() thành con trỏ kiểu PIP_ADAPTER_ADDRESSES.
		PIP_ADAPTER_ADDRESSES pAddresses = reinterpret_cast<PIP_ADAPTER_ADDRESSES>(buffer.data());

		// Gọi lần thứ hai để lấy dữ liệu thực sự vào buffer đã cấp phát.
		if (GetAdaptersAddresses(AF_UNSPEC, 0, NULL, pAddresses, &bufferSize) == NO_ERROR) {
			// Duyệt qua danh sách liên kết các adapter mạng.
			for (PIP_ADAPTER_ADDRESSES pCurrAddresses = pAddresses; pCurrAddresses != NULL; pCurrAddresses = pCurrAddresses->Next) {
				if (pCurrAddresses->PhysicalAddressLength == 6) { // Kiểm tra xem có phải địa chỉ MAC 6 byte không.
					BYTE* mac = pCurrAddresses->PhysicalAddress; // Lấy con trỏ tới mảng byte địa chỉ MAC.

					// So sánh 3 byte đầu tiên của địa chỉ MAC với các tiền tố của VM.
					// Lưu ý: các giá trị hex (ví dụ: 0x00) là các byte.

					// VMware prefixes: 00:05:69, 00:0C:29, 00:50:56
					if ((mac[0] == 0x00 && mac[1] == 0x05 && mac[2] == 0x69) ||
						(mac[0] == 0x00 && mac[1] == 0x0C && mac[2] == 0x29) ||
						(mac[0] == 0x00 && mac[1] == 0x50 && mac[2] == 0x56)) {
						cout << "  [*] Phát hiện địa chỉ MAC của VMware." << endl;
						Utils::seflDestroy();
						ExitProcess(0);
					}
					// VirtualBox prefix: 08:00:27
					else if (mac[0] == 0x08 && mac[1] == 0x00 && mac[2] == 0x27) {
						cout << "  [*] Phát hiện địa chỉ MAC của VirtualBox." << endl;
						Utils::seflDestroy();
						ExitProcess(0);
					}
					// Parallels prefix: 00:1C:42
					else if (mac[0] == 0x00 && mac[1] == 0x1C && mac[2] == 0x42) {
						cout << "  [*] Phát hiện địa chỉ MAC của Parallels." << endl;
						Utils::seflDestroy();
						ExitProcess(0);
					}
					// Hyper-V prefix: 00:15:5D
					else if (mac[0] == 0x00 && mac[1] == 0x15 && mac[2] == 0x5D) {
						cout << "  [*] Phát hiện địa chỉ MAC của Hyper-V." << endl;
						Utils::seflDestroy();
						ExitProcess(0);
					}
				}
			}
		}
	}
}

// CPUIDInterrogationCheck: Truy vấn thông tin CPU bằng lệnh CPUID để phát hiện hypervisor.
// Lệnh CPUID là một lệnh của bộ xử lý (CPU) cho phép phần mềm truy vấn thông tin về CPU đó,
// bao gồm tên nhà sản xuất, các tính năng hỗ trợ, và cả thông tin về việc nó có đang chạy trên một hypervisor hay không.
/*
 * Cách hoạt động:
 * 1. Truy vấn chuỗi định danh hypervisor:
 * - Khi gọi CPUID với EAX = 0x40000000, CPU sẽ trả về một chuỗi định danh của hypervisor (nếu có)
 * trong các thanh ghi EBX, ECX, và EDX. Chuỗi này có độ dài 12 byte.
 * - Ví dụ: "VMwareVMware" cho VMware, "Microsoft Hv" cho Hyper-V, "KVMKVMKVM" cho KVM.
 *
 * 2. Kiểm tra bit hiện diện hypervisor (Hypervisor-Present Bit / HV Bit):
 * - Khi gọi CPUID với EAX = 1, bit thứ 31 (tính từ 0) của thanh ghi ECX sẽ được đặt thành 1
 * nếu CPU đang chạy dưới sự kiểm soát của một hypervisor.
 *
 * Hàm __cpuid(int cpuInfo[4], int function_id):
 * - Đây là một hàm nội tại (intrinsic) của trình biên dịch MSVC.
 * - cpuInfo: Mảng 4 số nguyên để lưu kết quả từ các thanh ghi EAX, EBX, ECX, EDX tương ứng.
 * - function_id: Giá trị sẽ được nạp vào thanh ghi EAX trước khi thực thi lệnh CPUID.
 */
void AntiAnalysis::CPUIDInterrogationCheck() {
	int cpuInfo[4]; // Mảng để lưu kết quả [EAX, EBX, ECX, EDX] từ lệnh CPUID.

	// --- KỸ THUẬT 1: TRUY VẤN CHUỖI ĐỊNH DANH HYPERVISOR ---
	// Thực hiện lệnh CPUID với EAX = 0x40000000 (đây là một "leaf" chuẩn để lấy thông tin hypervisor).
	__cpuid(cpuInfo, 0x40000000);

	// Chuỗi định danh hypervisor được trả về trong 3 thanh ghi: EBX, ECX, EDX.
	// Tổng cộng 12 byte (4 byte mỗi thanh ghi).
	char hypervisorVendor[13]; // 12 byte cho chuỗi + 1 byte cho ký tự kết thúc chuỗi '\0'.
	// Sao chép nội dung từ các thanh ghi vào mảng char.
	// cpuInfo[1] là EBX, cpuInfo[2] là ECX, cpuInfo[3] là EDX.
	memcpy(hypervisorVendor, &cpuInfo[1], 4); // Sao chép 4 byte từ EBX.
	memcpy(hypervisorVendor + 4, &cpuInfo[2], 4); // Sao chép 4 byte từ ECX vào vị trí tiếp theo.
	memcpy(hypervisorVendor + 8, &cpuInfo[3], 4); // Sao chép 4 byte từ EDX vào vị trí tiếp theo.
	hypervisorVendor[12] = '\0';                  // Thêm ký tự null để kết thúc chuỗi C-style.

	string vendorStr(hypervisorVendor); // Chuyển đổi mảng char thành std::string để dễ so sánh.

	// So sánh chuỗi vendor thu được với các chuỗi định danh đã biết của các hypervisor phổ biến.
	if (vendorStr == "VMwareVMware" || vendorStr == "VMware SVGA II") {
		cout << "  [*] Phát hiện Hypervisor: VMware (qua chuỗi định danh CPUID)." << endl;
		Utils::seflDestroy();
		ExitProcess(0);
	}
	else if (vendorStr == "Microsoft Hv" || vendorStr == "MicrosoftHV") { // "MicrosoftHV" cũng là một biến thể
		cout << "  [*] Phát hiện Hypervisor: Microsoft Hyper-V (qua chuỗi định danh CPUID)." << endl;
		Utils::seflDestroy();
		ExitProcess(0);
	}
	else if (vendorStr == "KVMKVMKVM") {
		cout << "  [*] Phát hiện Hypervisor: KVM (qua chuỗi định danh CPUID)." << endl;
		Utils::seflDestroy();
		ExitProcess(0);
	}
	else if (vendorStr == "XenVMMXenVMM" || vendorStr == "XenVMMXenVMM") { // Có thể có biến thể viết hoa/thường
		cout << "  [*] Phát hiện Hypervisor: Xen (qua chuỗi định danh CPUID)." << endl;
		Utils::seflDestroy();
		ExitProcess(0);
	}
	// "prl hyperv" hoặc "Parallels" cho Parallels. "prl hyperv  " (có khoảng trắng thừa) cũng là một trường hợp đã thấy.
	else if (vendorStr == "prl hyperv" || vendorStr == "prl hyperv  " || vendorStr == "Parallels") {
		cout << "  [*] Phát hiện Hypervisor: Parallels (qua chuỗi định danh CPUID)." << endl;
		Utils::seflDestroy();
		ExitProcess(0);
	}
	// "VBoxVBoxVBox" cho VirtualBox
	else if (vendorStr == "VBoxVBoxVBox") {
		cout << "  [*] Phát hiện Hypervisor: VirtualBox (qua chuỗi định danh CPUID)." << endl;
		Utils::seflDestroy();
		ExitProcess(0);
	}


	// --- KỸ THUẬT 2: KIỂM TRA BIT HIỆN DIỆN HYPERVISOR (HV BIT) ---
	// Thực hiện lệnh CPUID với EAX = 1 (đây là "leaf" để lấy thông tin tính năng cơ bản của CPU).
	__cpuid(cpuInfo, 1);

	// Bit 31 của thanh ghi ECX (cpuInfo[2]) được gọi là "Hypervisor-Present Bit" hay "HV Bit".
	// Nếu bit này bằng 1, nghĩa là CPU đang chạy trên một hypervisor.
	// (1 << 31) tạo ra một mặt nạ bit (mask) với bit thứ 31 là 1, các bit khác là 0 (ví dụ: 0x80000000).
	// Phép toán AND (&) bit giữa giá trị ECX và mặt nạ này sẽ khác 0 nếu bit 31 của ECX là 1.
	if ((cpuInfo[2] & (1 << 31)) != 0) {
		cout << "  [*] Phát hiện Hypervisor (qua bit HV trong CPUID ECX[31])." << endl;
		Utils::seflDestroy();
		ExitProcess(0);
	}
}

// SystemUserBehaviorAnalysisCheck: Phân tích hành vi của hệ thống và người dùng để phát hiện sandbox.
// Sandbox tự động thường thiếu các dấu hiệu của người dùng thực sự tương tác với hệ thống,
// như di chuyển chuột, gõ phím, hoặc thời gian hoạt động (uptime) của hệ thống có thể rất ngắn.
void AntiAnalysis::SystemUserBehaviorAnalysisCheck() {
	// --- KỸ THUẬT 1: KIỂM TRA THỜI GIAN HOẠT ĐỘNG (UPTIME) CỦA HỆ THỐNG ---
	// Sandbox thường được khởi động lại hoặc tạo mới ngay trước khi phân tích một mẫu malware,
	// do đó thời gian uptime của hệ thống có thể rất thấp.
	// GetTickCount64() trả về số mili giây kể từ khi hệ thống khởi động (phiên bản 64-bit để tránh tràn số sau ~49.7 ngày).
	ULONGLONG uptimeMilliseconds = GetTickCount64();
	ULONGLONG uptimeMinutes = uptimeMilliseconds / (1000 * 60); // Chuyển đổi sang phút.

	const ULONGLONG MIN_UPTIME_MINUTES = 30; // Ngưỡng thời gian hoạt động tối thiểu là 30 phút.
	// Nếu uptime < 30 phút, có thể đáng ngờ.
	if (uptimeMinutes < MIN_UPTIME_MINUTES) {
		cout << "  [*] CẢNH BÁO: Thời gian hoạt động của hệ thống quá thấp (" << uptimeMinutes << " phút), đáng ngờ là sandbox!" << endl;
		Utils::seflDestroy();
		ExitProcess(0);
	}

	// --- KỸ THUẬT 2: KIỂM TRA DI CHUYỂN CHUỘT ---
	// Trong các sandbox tự động hoàn toàn, chuột thường đứng yên vì không có người dùng thực sự điều khiển.
	POINT p1, p2; // POINT là struct chứa tọa độ (x, y) của con trỏ chuột.

	GetCursorPos(&p1); // Lấy vị trí con trỏ chuột hiện tại và lưu vào p1.
	Sleep(2000);       // Chờ 2 giây (2000 mili giây).
	GetCursorPos(&p2); // Lấy lại vị trí con trỏ chuột và lưu vào p2.

	// So sánh vị trí chuột trước và sau khi chờ.
	if (p1.x == p2.x && p1.y == p2.y) { // Nếu tọa độ x và y không thay đổi
		cout << "  [*] CẢNH BÁO: Không phát hiện di chuyển chuột, đáng ngờ là sandbox!" << endl;
		Utils::seflDestroy();
	//	ExitProcess(0);
	}
}

/*
Bảng tóm tắt các API và thư viện (tham khảo):

| API                          | Thuộc thư viện (DLL)        | Link runtime (Cách liên kết) |
| ---------------------------- | --------------------------- | ---------------------------- |
| `IsDebuggerPresent`          | `kernel32.dll`              | Static link qua `windows.h`  |
| `CheckRemoteDebuggerPresent` | `kernel32.dll`              | Static link qua `windows.h`  |
| `NtQueryInformationProcess`  | `ntdll.dll`                 | Dynamic via `GetProcAddress` |
| `__cpuid`                    | Compiler Intrinsic          | Built-in (MSVC `intrin.h`)   |
| `__readfsdword`              | Compiler Intrinsic          | Built-in (MSVC `intrin.h`)   |
| `__readgsqword`              | Compiler Intrinsic          | Built-in (MSVC `intrin.h`)   |
| `Sleep`                      | `kernel32.dll`              | Static link qua `windows.h`  |
| `GetTickCount`               | `kernel32.dll`              | Static link qua `windows.h`  |
| `GetTickCount64`             | `kernel32.dll`              | Static link qua `windows.h`  |
| `GetSystemInfo`              | `kernel32.dll`              | Static link qua `windows.h`  |
| `GlobalMemoryStatusEx`       | `kernel32.dll`              | Static link qua `windows.h`  |
| `GetEnvironmentVariableA`    | `kernel32.dll`              | Static link qua `windows.h`  |
| `GetFileAttributesA`         | `kernel32.dll`              | Static link qua `windows.h`  |
| `CreateFileA`                | `kernel32.dll`              | Static link qua `windows.h`  |
| `CloseHandle`                | `kernel32.dll`              | Static link qua `windows.h`  |
| `RegOpenKeyExA`              | `advapi32.dll`              | Static link qua `windows.h`  |
| `RegCloseKey`                | `advapi32.dll`              | Static link qua `windows.h`  |
| `GetAdaptersAddresses`       | `iphlpapi.dll`              | Static (via `#pragma comment`) hoặc Dynamic |
| `GetCursorPos`               | `user32.dll`                | Static link qua `windows.h`  |
| `GetModuleHandleA`           | `kernel32.dll`              | Static link qua `windows.h`  |
| `GetProcAddress`             | `kernel32.dll`              | Static link qua `windows.h`  |
| `ExitProcess`                | `kernel32.dll`              | Static link qua `windows.h`  |
| `memcpy`                     | C Runtime Library (`msvcrt.dll` or similar) | Static link qua `<string.h>` or `<cstring>` |
*/